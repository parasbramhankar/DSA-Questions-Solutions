package Recursion.Easy.FindtheKthCharacteInStringGameI3304;

import java.util.Scanner;

/*
==================================================================================
 Core Logic and Approach of kthCharacter(int k) [In-Depth Explanation]
==================================================================================

 This algorithm finds the kth character in a hypothetical sequence generated by a
 special process. The process starts with the character 'a' and, at each stage,
 doubles the previous sequence and shifts every character forward in the alphabet
 (e.g., 'a' -> 'b', 'b' -> 'c', ..., 'z' -> 'a').

 The sequence evolves like this:
    Stage 1: "a"
    Stage 2: "a" + "b"      => "ab"
    Stage 3: "ab" + "bc"    => "abbc"
    Stage 4: "abbc" + "bccd"=> "abbcbccd"
    ... and so on.

 Attempting to build this sequence directly would require exponential space and time.
 Instead, this recursive solution leverages the structure of the process using powers
 of two and repeated character shifting.

 ---- MAIN IDEAS ----

 1. Find the largest power of 2 (pow2) less than or equal to k.
    This gives the start position of the current "layer" in the sequence.
 2. If k == 1, return 'a', the base character.
 3. Otherwise, subtract pow2 from k to get correspondingPos - this represents the
    position within the previous layer before applying the shift.
 4. Recursively find the character for correspondingPos, and then shift it forward
    by one (i.e., add 1 to the char value).
 5. Each recursion layer adds another +1 shift, meaning the answer is 'a' shifted by
    the number of recursions required to reach k.

 ---- EXAMPLE ----
   For k = 10:
   - pow2: 8 ("layer" starts at position 9)
   - correspondingPos = 10 - 8 = 2
   - kthCharacter(2): pow2 = 1, correspondingPos = 2 - 1 = 1
   - kthCharacter(1): returns 'a'
   - kthCharacter(2): returns (char)('a' + 1) = 'b'
   - kthCharacter(10): returns (char)('b' + 1) = 'c'

 ---- TIME COMPLEXITY ----
   The number of recursions equals the number of times k can be divided by 2.
   Therefore, time complexity is O(log k).

 ---- SUMMARY FOR FUTURE REFERENCE ----
   - Use recursion, always resolving to kthCharacter(1) = 'a'.
   - Each step moves position down to the largest previous power of 2, then increments
     the result.
   - The character obtained is 'a' shifted by the number of layers traversed.

 Paste this section above your code for clear future reference.
==================================================================================
*/


public class OptimizeSolution {


    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);

        System.out.println("Enter the value of K");
        int k = scanner.nextInt();

        char ch = kthCharacter(k);
        System.out.println(ch);
    }

    /**
     * Recursively finds the kth character in the expanding sequence.
     *
     * The sequence starts with 'a', then successively builds by:
     * - Concatenating previous step, then
     * - Incrementing each character (e.g., 'a'->'b', 'b'->'c', ..., 'z'->'a')
     *
     * The pattern means positions relate to powers of 2: the sequence length
     * after each stage is a power of two.
     *
     * This method works back to the base case (k==1), then calculates the cumulative 'shifts'.
     */
    public static char kthCharacter(int k) {
        // Base case: the very first character is always 'a'.
        if (k == 1) {
            return 'a';
        }

        // Find the largest power of 2 less than k.
        int pow2 = 1;
        while (pow2 * 2 < k) {
            pow2 = pow2 * 2;
        }

        // How far past the previous power of 2 is k?
        int correspondingPos = k - pow2;

        // Recursively find the shift contributed by the previous layers,
        // then add 1 ('next letter') for each layer as you go deeper.
        return (char) (kthCharacter(correspondingPos) + 1);
    }

}
/**
 Dry run for k = 1:
 kthCharacter(1)
 => returns 'a'
*/

/*
 Dry run for k = 5:
 Step 1: pow2 = 1, then pow2 = 2, then pow2 = 4 (since 4*2=8 > 5)
 correspondingPos = 5 - 4 = 1
 kthCharacter(1) returns 'a', so we shift 'a' by 1: 'b'
 kthCharacter(5) returns (char)('a' + 1) => 'b'
 */

